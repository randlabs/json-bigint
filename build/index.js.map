{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@randlabs/json-bigint/webpack/bootstrap","webpack://@randlabs/json-bigint/webpack/runtime/define property getters","webpack://@randlabs/json-bigint/webpack/runtime/hasOwnProperty shorthand","webpack://@randlabs/json-bigint/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const reFindBigNumbers = /(^|[[:,]\\s*)(-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)/ugm;\nexport default class JSONBigInt {\n    static parse(text, reviver, options) {\n        if (reviver && typeof reviver === \"object\") {\n            options = reviver;\n            reviver = null;\n        }\n        let bigNumberParse;\n        if (options && options.bnParse) {\n            bigNumberParse = options.bnParse;\n        }\n        else {\n            bigNumberParse = function (value) {\n                return BigInt(value);\n            };\n        }\n        const tag = JSONBigInt.generateTag();\n        if (typeof text === 'string') {\n            const matches = [];\n            let match;\n            const nonQuotedFragments = [];\n            let nonQuotedStartIdx = 0;\n            for (let startIdx = 0;;) {\n                let quoteIdx = text.indexOf('\"', startIdx);\n                if (quoteIdx < 0) {\n                    nonQuotedFragments.push({\n                        start: nonQuotedStartIdx,\n                        end: text.length\n                    });\n                    break;\n                }\n                if (quoteIdx > 0 && text.charAt(quoteIdx - 1) == '\\\\') {\n                    startIdx = quoteIdx + 1;\n                    continue;\n                }\n                nonQuotedFragments.push({\n                    start: nonQuotedStartIdx,\n                    end: quoteIdx\n                });\n                do {\n                    startIdx = quoteIdx + 1;\n                    quoteIdx = text.indexOf('\"', startIdx);\n                } while (quoteIdx > 0 && text.charAt(quoteIdx - 1) == '\\\\');\n                if (quoteIdx < 0) {\n                    break;\n                }\n                startIdx = quoteIdx + 1;\n                nonQuotedStartIdx = startIdx;\n            }\n            for (const frag of nonQuotedFragments) {\n                const str = text.substring(frag.start, frag.end);\n                reFindBigNumbers.lastIndex = 0;\n                while ((match = reFindBigNumbers.exec(str)) !== null) {\n                    const num = parseInt(match[2], 10);\n                    if (Number.isNaN(num) || (num >= Number.MIN_SAFE_INTEGER && num <= Number.MAX_SAFE_INTEGER)) {\n                        continue;\n                    }\n                    matches.push({\n                        ofs: frag.start + match.index + match[1].length,\n                        len: match[2].length,\n                        repl: match[2]\n                    });\n                }\n            }\n            let idx = matches.length;\n            while (idx > 0) {\n                idx -= 1;\n                const str = \"{ \\\"\" + tag + \"\\\": \\\"\" + matches[idx].repl + \"\\\" }\";\n                text = text.substr(0, matches[idx].ofs) + str + text.substr(matches[idx].ofs + matches[idx].len);\n            }\n        }\n        let obj = JSON.parse(text, reviver ? reviver : undefined);\n        const cv = JSONBigInt.convertTaggedBigNumbers(obj, tag, bigNumberParse);\n        if (cv) {\n            obj = cv;\n        }\n        return obj;\n    }\n    static stringify(value, replacer, space, options) {\n        if (replacer && typeof replacer === \"object\") {\n            options = replacer;\n            replacer = null;\n            space = null;\n        }\n        else if (space && typeof space === \"object\") {\n            options = space;\n            space = null;\n        }\n        const tag = JSONBigInt.generateTag();\n        value = JSONBigInt.shallowCopyAndTagBigNumbers(value, tag, options ? options.bnStringify : null);\n        let str = JSON.stringify(value, replacer ? replacer : undefined, space ? space : undefined);\n        const openingQuoteTag = \"\\\"\" + tag;\n        const closingQuoteTag = tag + \"\\\"\";\n        let startIdx = 0;\n        for (;;) {\n            const idx = str.indexOf(openingQuoteTag, startIdx);\n            if (idx < 0) {\n                break;\n            }\n            const valueStartIdx = idx + openingQuoteTag.length;\n            const valueEndIdx = str.indexOf(closingQuoteTag, valueStartIdx);\n            if (valueEndIdx < 0) {\n                break;\n            }\n            str = str.substr(0, idx) + str.substr(valueStartIdx, valueEndIdx - valueStartIdx) +\n                str.substr(valueEndIdx + closingQuoteTag.length);\n            startIdx = idx + (valueEndIdx - valueStartIdx);\n        }\n        return str;\n    }\n    static generateTag() {\n        return \"tag\" + Date.now().toString() + Math.floor(Math.random() * 100000).toString();\n    }\n    static convertTaggedBigNumbers(obj, tag, bigNumberParse) {\n        if (obj != null && typeof obj === 'object') {\n            const keys = Object.keys(obj);\n            if (keys.length == 1 && keys[0] == tag) {\n                return bigNumberParse(obj[tag]);\n            }\n            for (let idx = 0; idx < keys.length; idx++) {\n                const cv = JSONBigInt.convertTaggedBigNumbers(obj[keys[idx]], tag, bigNumberParse);\n                if (cv != null) {\n                    obj[keys[idx]] = cv;\n                }\n            }\n        }\n        return null;\n    }\n    static shallowCopyAndTagBigNumbers(obj, tag, bigNumberStringify) {\n        if (bigNumberStringify) {\n            const s = bigNumberStringify(obj);\n            if (typeof s === \"string\") {\n                return tag + s + tag;\n            }\n        }\n        if (typeof obj === \"bigint\") {\n            return tag + obj.toString() + tag;\n        }\n        if (obj != null && typeof obj === 'object') {\n            const keys = Object.keys(obj);\n            const newObj = Array.isArray(obj) ? [] : {};\n            for (let idx = 0; idx < keys.length; idx++) {\n                newObj[keys[idx]] = JSONBigInt.shallowCopyAndTagBigNumbers(obj[keys[idx]], tag, bigNumberStringify);\n            }\n            return newObj;\n        }\n        return obj;\n    }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","reFindBigNumbers","JSONBigInt","static","text","reviver","options","bigNumberParse","bnParse","value","BigInt","tag","generateTag","matches","match","nonQuotedFragments","nonQuotedStartIdx","startIdx","quoteIdx","indexOf","push","start","end","length","charAt","frag","str","substring","lastIndex","exec","num","parseInt","Number","isNaN","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","ofs","index","len","repl","idx","substr","JSON","parse","undefined","cv","convertTaggedBigNumbers","replacer","space","shallowCopyAndTagBigNumbers","bnStringify","stringify","openingQuoteTag","closingQuoteTag","valueStartIdx","valueEndIdx","Date","now","toString","Math","floor","random","keys","bigNumberStringify","s","newObj","Array","isArray"],"sourceRoot":""}